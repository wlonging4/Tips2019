<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>第二周周末</title>
</head>
<body>
<script type="text/javascript">
    //判断DOM元素的构造函数;
    /*oLis.__proto__.constructor;//->HTMLLIElement
    oDivs.__proto__.constructor;//->HTMLDivElement
    oText.__proto__.constructor;//->Text
    oP.__proto__.constructor;//->HTMLParagraphElement
    document;//->HTMLDocument
    oComment;//->Comment*/
    //各标签对应的的类的特点:HTML[标签对应的英文名]Element;


    //面向对象中继承实现管理;面向对象适合大型,设计模式较高级的方法;项目小逻辑比较多面向过程的反而适合JS;
    //EventTarget方法包含addEventTarget及removeEventTarget等方法;
    /*oLi.addEventListener("click", function () {},false);
    oLi.onclick= function () {};//与上面相等
    oL.removeEventListener();//新版的事件方法;API*/


    //【①typeOf】
    /*用来检测数据类型的返回值->字符串,包含了常用的数据类型(不包含null);
    typeOf null;->'obeject'因为null是一个空对象指针;
    typeOf不能区分对象,数组,正则等;*/
    //【②instanceOf/construcor】
    /*//检测当前实例是否属于某一个类->返回ture/false;
    ary instanceof Array->ture;
    //只要在这个实例原型链上的类,经过instanceof检测时结果都是ture；
    //instanceof的局限性->在类的继承中我们只是单纯通过instanceof来检测的话是不准确的;
    F(){};
    F.prototype=new Array;
    var f=new F;
    console.log(f instanceof F);//->true;
    console.log(f instanceof Array);//->true;
    // f继承了数组中常用的方法,但是不是数组;不过instanceof输出确实true;
    ary.constructor===Array->ture;
    //constructor不严谨,因为用户可以自己修改;所有一般不采用这种方法;*/
    //【③toString】方法:来通过这个特征来判断这个对象是不是html元素;
    /*[object Object]前面是表示是Object类型,后面是实例具体所属的内置类;
    function F{};
    var f=mew F;
    console.log(d/tostring)->obeject，Object
     任何数据类型下面都对应一个toString;null,undefined屏蔽掉了任何方法;
     (1).toString();->"1"
     (function(){}).toString；->""
     对于数字,布尔,数组,函数等数据类型是转换成字符串;但是对于对象（{}）数据类型来说,不是啊直接的转换成字符串那么简单;而是返回的是当前实例的数据类型[object Object]；
     Object.prototype.toString.call(传递一个值);//->[object XXX];
     Object.prototype.toString.call(NaN);//->[object number]
     Object.prototype.toString.call(isNaN);//->[object Function]
     【括号表达式】
     （function(){}）;//定义个函数
     （{name:20}）;//定义一个对象
     括号内分别定义两个函数->只执行后面那个
     eval=(1,2,3,4);->4；
     function fn(){console.log(this);}
     var obj={fn:fn};
     fn();//this->window；
     obj.fn();//this->obj；
     (fn,obj.fn)();//this->window；
     （obj.fn,obj.fn）;//this->window
     对于括号表达式,如果括号里面只有一部分内容,这样写是为了满足语法,不然是变态;
     如果括号内有两个及以上部分内容,这样写是变态,写两部分都定义了,但是只有最后一部分执行,并且执行的时候里面的this就是window；
     来个正则方法
     function isType(value,type){
     var reg=new RegExp("\\[object "+type+"\\]$","i");
     return reg.test(object.prototype.toString.call(value));
     }
     在正则表达式构造函数模式方法中,由于第一个参数传递的是一个字符串,所以这里转义字符只有\\两个同时出现才会起到作用;左边的是把右边的变为可以转义的转义字符;



     对象类型按照[obeject 构造函数名]输出的
     对于标准浏览器（不包含IE）html元素则会输出[obeject HTML[TagName]Elemnet];
     function isEle(obj){
     var reg=/\[obeject HTML[A-Z]\w*Element\]/;//[]需要转义一下\[-\];
     return reg.test(obj.toString());
     }
     【toString重写】
     object.prototype.toString.call()
     Object.prototype.toSring约定好这样输出;但是也是可以重写;
     Array.prototype.toString=function(){
     return this.join(",");
     }
     模拟重写toString
     function isArray(obj){
     //return obj.toString()=="[object Array]"；->会重写系统的方法，用下面的方法;
     return Object.prototype.toString.call(obj);
     }


     8+{};隐式调用(分别隐式调用Number类上和Object类上的toString)->"8[obeject Object]"
     常见的类都会重写;
     var d=new Date;
     d.toString();
     Number类上的toString特点->转换进制
     toString实现实例的识别
     【null和undefined】也是有类的
     null是主动的没有对应的类;undefined是被动没有;
     null/undefined.toString()->报异常,因为null/undefined屏蔽了所有的方法
     Object.prototype.toString.call(null);->[Object null];
     Object.prototype.toString.call(undefined);->[Object undefined];


     toString来判断DOM类的名称特点
     document.toString();->[object HTMLDocument];
     document.body.toString();->[object HTMLBodyElement];
     p1.toString();->[object HTMLParagraphElement];
     div1.toString();->[object HTMLDivElement];
     Object.prototype.toString()实现严格判断数组
     instanceof/typeof不是方法,只是运算符,并且不严谨
     var a=[];
     alert(a.instanceOf Array);
     alert(a instanceof  Object);
     不严谨->两个都是true,是这两个的实例;*/

    //【nodelist】
    /*DOM映射
    进行简单列表排序;
    ①活的
    ②它是随着元素增加或者减少动态变化的,但是不直接修改集合本身;
    ③元素的顺序严格的按着网页上元素的顺序排列。如果网页上的元素顺序发生改变了，则这个集合也会自动改变
    */
    //【call/apply;列表排序】
    /*【JSON】
    JSON复合格式
    数组格式的JSON->[{},{},...]；
    eval的使用({})强制转换括号内的"值"为object;
     */

    //【垃圾面试题】
    //var x=20;
    //var obj={x:10,fn:function(){alert(this.x)}};
    //(obj.fn)();//10
    // 一个属性和一个变量直接放在括号里还是属性本身;
    //(obj.fn=obj.fn)();//20
    //但是在括号里一旦是个运算的表达式;①obj.fn=obj.fn;②temp=obej.fn;赋值给一个匿名变量;相当于最后把obj.fn上的方法赋给了一个无宿主的变量或属性->括号运算符返回了一个匿名方法->window下面的x=20；
    //(1,2,3,obj.fn)();//20





</script>
</body>
</html>