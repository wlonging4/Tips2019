<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>第二周第三天</title>
</head>
<body>
<script type="text/javascript">
    /*substring(startindex,endindex);包括第一个index的内容,不包括第二个index的内容,类似数组的slice;
    substr(startindex,length);第一个参数是开始index,包含index的内容,第二个是length;
    字符串所有方法使用了,改变的是返回值,但是原先的字符串内容顺序不会发生改变->因为字符串是基本数据类型;
    str.split("");和str.split([]);
    console.log(str.split(""));
    console.log(str.split([]));

    【正则表达式】
    作用:用来处理字符串,尤其是复杂的字符串;
    正则表达式定义的事字符串的pattern模型,我们可以使用这个模型去验证某个字符串（或其中的一部分）是否和这个模型匹配;如果匹配就把那部分找出来;
    ①匹配:定义的这个正则的模式的描述和字符串是相符合的,匹配只是逻辑上的;
    ②捕获:把匹配到的内容拿到;
    正则的特性:贪婪而懒惰;
    正则只是定义了一个字符串模型,如何验证查找是正则类上的方法(或者是字符串上的方法)完成的;
    var reg=/内容/;两个"/"之内的内容表示一个正则对象;
    var reg=/\d+/;一个数字出现一次到多次;
    var reg=/^\d+$/;严格的匹配一个到多个数字,不能出现其他字符;
    var ary="我的号码是18672787271,请保存下";
    var reg=/\d{11}/;
    var reg=/1\d{10}/;
    var reg=/1[345678]\d{9}/;
    【定义正则】
    ①对象直接量方式->var reg=/abcd/;var reg=/abcd/g;
    ②构造函数方式->var reg=new RegExp("abcd");var reg=new RegExp("abcd","g");
    【元字符】正则中表示特殊含义的字符;
     /*
     表示数量的元字符有*,+,?,{n},{m,n};量词是修饰它前面的实义符号的;
        *->表示前面的字符出现0-n次;/12345* /可以捕获的是必须包含1234+0~n个5的字符串;
        /(12345)* /->无效的正则，什么都可以匹配;
        +->1-n次->zo+匹配zo或者zoo
        ?->0-1次(?在不同的位置有不同的规则)
        {n}中n表示非负整数表示匹配确定的n次;->a{2}匹配faak,不匹配fak;
        {n,}至少匹配n次;a{0,}==a*;
        {n,m}->n<m最少匹配n次最多匹配m次;
    ?紧跟在以上限制符的后面,匹配模式是非贪婪的,非贪婪模式尽可能少的匹配所搜索的字符串,而默认的贪婪模式则尽可能多的匹配所搜索的字符串,例如oooo中"o+?"将匹配单个的o,而"o+"将匹配所有的o;
    */
    /*
    实义元字符
    \将后面字符标记为一个特殊字符或原义字符->\\表示"\"
    \d表示匹配数字;->[0-9];
    \D表示匹配一个非数字字符;[^\d]->[^0-9];
    \w表示常用字符;->[0-9a-zA-Z_];
    \W表示非常用字符;->[^\w]->[^0-9a-zA-Z_];
    \b表示边界,这是个逻辑上的含义,就是常用字符和非常用字符之间的逻辑位置叫“边界”->\w和\W的逻辑边界;
        var str="Jerry@moker,my,ele#186";
        var a=str.split(/\b/);
        console.log(a);//->["Jerry", "@", "moker", ",", "my", ",", "ele", "#", "186"]
    \B表示匹配非单词边界;
    .表示非换行(\n)回车符之外的任意字符,也就是说只表示一行中的任意字符();
    如果想匹配任意字符,包含换行回车->reg=/[\B\b]/=/[\W\w]/=/[\D\d]/;
    \n表示一个换行符==\xoa==\cJ;
    \r表示一个回车符==\xob==\cM;
    \f表示一个换页符==\xoc==\cL;
    \t表示一个制表符==\x09==\cI;
    \v表示一个垂直制表符==\x0b==\cK;
    \s表示任何空白字符=[\n\r\f\t\v];
    \S==[^\s]表示任何非空白字符;
    */
    /*
    表示实现严格匹配的元字符:^和$;
    ^表示用在一个正则的开始,修饰其后面的实义字符,表示它后面的这个字符一定要出现在字符的开始的属性;匹配输入字符串的开始位置,如果设置了RegExp对象的Multiline属性,^也匹配\n或者\r之后的位置;
    $表示用在一个正则的结尾,修饰其前面的实义字符,表示它前面的这个字符一定要出现在字符的结束的属性;匹配输入字符串的结束位置,如果设置了RegExp对象的Multiline属性,$也匹配\n或者\r之前的位置;
    ^\d表示以任意数字开头;
    \d$表示以任意数字结尾;
    ^\d8\d$表示三位数字,之间数字是8;可以匹配281,082等字符串;不能匹配2281等;
    */
    /*
    g(global)表示模式修正符,表示在字符串中多次查找;
    m(multiple)表示多行匹配,用在字符串中出现/n等换行符的情况下;
    i(ignore)表示忽略大小写;
    (pattern)匹配括号里的pattern并获取这个匹配;
    (?:pattern)匹配括号里的pattern不获取这个匹配;结合'|''或'使用非常棒;
    (?=pattern)正向预查:非获取匹配;
    (?!pattern)非向预查:非获取匹配;
    预查不消耗字符;在一个匹配发生后,在最后一次匹配之后立即开始下一次匹配的搜索,而不是从包含预查的字符之后开始;

    x|y->匹配x或者y->(z|f)ood->zood和food;
    [xyz]->匹配里面任意一个字符->ozen中的z,xray的x和y..
    [^xyz]->匹配未包含的任意字符->ozen中的o..
    [a-z]->匹配任意小写字母
    [^a-z]->匹配任何不再这个范围的任意字符
    */
    /*
     【元字符及实例应用】
     reg=/c{1}/;//->匹配一个c->如果是caco只会匹配第一个c因为正则是懒惰的,后面加g才能完全匹配;
     reg=/c{n}/;//->匹配n个连续c
     reg=/c{m,n}/;//->如果cccc,reg=/c{3,4}/;->那么会匹配四个,这是贪婪匹配;
     reg=/c{n,}/;//->会贪婪匹配,尽可能多的匹配c;
     //!*->{0,};+->{1,};?->{0,1}
     在上述的}后面加上?就变成非贪婪模式;
     {n,}?;  *?;  +?;  ??;  {m,n}?
     reg=/^a/;//->alphaB->exec输出返回"a";
     reg=/B$/;//->alphaB->exec输出返回"B";
     reg=/./;//->一个点表示匹配字符串中第一个非换行符字符;
     reg=/.+/;//->匹配行内所有直到结尾;
     reg=/^./;//->必须以非换行符开始->str="\n我来了";会返回null;
     reg=/^z|o.+/;//->匹配开头的z和o后面是一连串连续的字符;->str="online"->"onlone";str2="zhengfujie"->"z";可以理解为(^z)和(o.+)两部分;
     reg=/^(z|o).+/;//->才是表示的返回以z或者o开头及后面连续字符;
     reg=/[a-zA-Z0-9]/;//->表示的是\w;/[-]表示的是要以ASCII码表里的顺序进行操作,如果要以16进制表示则得写成\u0012这样类似的格式/
     reg=/[1-14]/;//表示的不是1-14数字,而是表示从1到1或3;
     reg=/[^]/;//表示的是所有的非空字符串(而不是非空格);
     reg=/[*]/;//[]里的*+=？表示的是字符,而不是元字符;
     reg=/[^abc]/;//^在//中表示的开头;但是在[]中表示的是"非";->str=abc3;->返回的是3;
     reg=/\bc/;//表示的是边界->ca->返回c;ac->也返回c;
     reg=/\s.+/;//表示的是空白换行符开始和后面的内容;'a is b'->' is b';
     reg=/\S+/;//表示的是非空白;'a is b'->返回'a';遇到a后面的空白符就停止了;
     reg=/^\s*$/;//匹配任意空或者空白字符;如果没输入,或者输入的是空白符,则匹配成功;这样可以验证用户输入是否包含内容,这是一个正则常见的应用;var reg=/^\s*$/;if(reg.test(value)){alert("请输入内容");return flase;}
     reg=/(\w)(\w)/;//str="wlg";->wl,w,l;括号的应用;wl是正则匹配内容;w和l是第一个和第二个括号里子正则匹配内容;
     reg=/(\w)\1/;//\1表示的是反向引用;'bbst'->bb,b万恶的括号小正则;
     reg=/^(?:b|c)/;//匹配不捕获;?:不记录子正则表达式的匹配结果;'bbs'->'b'
     reg=/^(?:(b|c)\1/;//因为匹配不捕获所以\1根本不知道是指什么导致不开心,返回null;
     reg=/a(?=b)/;//ab->返回;ac->返回a;不返回ac是因为括号里的内容只是条件,并不参与真正的捕获;
     reg=/a\*!/;//匹配元字符,转义*为普通字符;
     reg=/b/i;//BBS->B;i表示不区分大小写;
     reg=/^b/m;//m表示可以从换行之后的首位查找str="asd\nbsc"->b会查找到第二行的b;
     */
    //元字符和普通字符构成了正则最基本的单位-原子;
    //【正则的括号】
    var str1="ab12345555ff";
    var str2="xy2234552345cd";
    var reg1=/2345+/;
    var reg2=/(?:2345)+/;
    //括号里?:表示匹配不捕获,防止括号里面再形成小正则表达式;不加输出结果会变成两个;
    //括号的意义表示优先级,表示这是一个子正则,就是分组的概念;
    console.log(str1.match(reg1));//2345555
    console.log(str1.match(reg2));//2345
    console.log(str2.match(reg1));//23455
    console.log(str2.match(reg2));//2345

    /*var str1="I am a Chinese";
    var str2="I am an American";
    var reg=/I am (?:a|an) (?:Chinese|Japanese|American|Canadian)/;
    alert(str1.match(reg));
    alert(str2.match(reg));*/
    //在括号里面添加'？:'防止括号内形成小正则再次运行输出这样的结果I am a Chinese,a,Chinese;

    var reg=/[abcdefg]/;
    reg=/[0-9]/;//'-'表示连续按顺序出现在ASCII表中的字符;'-'什么时候才表示前后的连字符呢?它前后的字符必须要在ASCII码表是按顺序出现的;
    reg=/[0-99]/;//这不表示0~100,因为正则处理的是字符串,不认识数字100;
    reg=/[\w]/;//正则方括号中可以出现元字符,但不能出现单字符的元字符;
    reg=/.\s/;//'/s'表示所有看不见的字符+'.'表示所有非空的字符;->但这并不是表示所有的字符集合->而是表示'.'本身和不可见字符;
    reg=/[.+?]/;//这个只表示'.'和'?'本身;[]中括号里的这里的'.''+''*''?'都已经不再是表示元字符了,而是这个字符本身;
    reg=/[a-z]/i;//i表示忽略大小写;
    reg=/[1-12]/;//表示的不是数字1-12而是指到1到1或3,正则不是数字,而是连续的字符;
    reg=/[a-z-]/;//想匹配从a-z再加上'-'的正则;只要'-'不出现在连续的两个字符的中间,就不会被认为是连字符;把'-'放在开头或者结尾;
    //【分组引用】用括号来进行分组;
    //分组引用的一个前提就是不能在分组里加'?';
    /*reg=/^(\d)\d\1$/;//表示只能匹配三位的纯数字字符串;\1表示第一个括号中匹配了什么内容,这里一定也匹配这个内容;->212,222,313,353等;
    reg=/(\d)(\d)\2\1/;//可以匹配1221,4664等;
    reg=/(\w)(\w)\2\1/;//表示是abba等;
    reg=/^(\d)(\d)\1\1\1$/;//只有第二个位置上的数字是可以不一样;其他位置的必须都一样;
    //验证一个字符是不是完全重复的数字:7777777;
     reg=/\d+/;//这个只表示连续出现的数字，但数字未必相同
     【区别】
     reg=/^(\d)\1+$/;//使用分组引用，使第二个到第n个位置上出现的内容和第一个位置上的内容（分组中的）相同
     reg=/^(\d)+\1$/;//这个正则倒底是表示首尾相同呢还是最后两位相同呢？表示最后两位相同，为什么呢？
     //这个正则可以验证"12345677",但是不能验证"12345671";
    //【RegExp的$1~$99】
    //【正向预查和负向预查】
    /*带条件的正则;
    正向预查->满足这个条件叫正向预查;条件写在前面要谨慎;
    负向预查->条件不满足叫负向预查;负向预查不好把握;*/
    var str1="abc123zhufeng";//->123;
    var str2="abc123zhufengPX";//->null;
    var reg1=/\d+(?=zhufeng$)/;//匹配结尾是zhufeng的那些数字;(?=zhufeng$)这个是正则的条件,它不参加捕获;当字符串满足了括号里的?=后面的这个条件的描述的时候,才会捕获\d+的内容;
    console.log(reg1.exec(str1));//->123
    console.log(reg1.exec(str2));//->null
    var str3="abc456zhufeng";
    var str4="abc987zfg";
    var reg2=/\d+(?!zhufeng$)/;
    console.log(reg2.exec(str3));//->45?上面的正则貌似不会通过这个字符串,因为他右边结尾确实是zhufeng,但是也可以看作是6zhufeng,所以下面还是会弹出45;若果把正则修改下,改成捕获固定长度数字就好了;->reg2=/\d{3}(?!zhufeng)/;
    console.log(reg2.exec(str4));//->987

    //【字符串去重】
    var str='222333888999';
    var newStr1=str.replace("3","a");//只替换了第一个
    var newStr2=str.replace(/3/,"a");//全替换
    var newStr3=str.replace(/(\d)\1+/g,"$1");//$1表示第一个分组匹配到的内容
    alert(newStr3);
    //【文字数字转换】
    var str='328107';
    var ary=['零','壹','贰','叁','肆','伍','陆','柒','捌','玖'];
    //replace的第二个参数可以跟一个函数;
    var newStr=str.replace(/\d/g,function(){
        return ary[arguments[0]];
    });
    alert(newStr);

    var n=0;
    var str="abcdxyz";//把这个字符串中的字母用他们的索引位置替换
    newStr=str.replace(/\w/g,function(){
    //传最少三个参数;
    //第一个参数是正则/\w/g捕获到的内容;->如果有括号有小正则,那么arguments[1],[2],[3]...
    //第二个参数是捕获到的内容(第一个参数)在原字符串中的索引位置;
    //第三个参数是源字符串str,也叫输入字符串;
    //return替换的是大正则,不理会小正则;没有返回值默认输出undefined;
        return arguments[1];
    });
    alert(newStr);
    //【调试工具】
    /*
     F12打开控制台->
     点击source->
     在navagitor导航双击要调试的页面->
     看到你要调试的那一行代码的行号点击一下设置断点->
     再让代码执行->
     F8->逐断点调试
     F10->逐过程调试
     F11->逐语句调试
     */
    //【正则类方法】
    var str="我的号码是18672787271,请保存下";
    var reg=/\d{11}/;
    var a1=reg.exec(str);//由正则类方法
    var a2=str.match(reg);//由正则类方法
    console.log(a1);
    console.log(a2);
    /*【思考题】
    转换数字为千分符制*/
    //DIY
    function kilo(x){
        var x1=x.replace(/\d/g,function(){
            if(((arguments[1]%3)===((x.length)%3))&&(arguments[1]!==0)){
                    return "," + arguments[0];
            }else{
                return arguments[0];
            }
        });
        alert(x1);
    }
    var str1="1234567";
    var str2="234567";
    var str3="34567";
    var str4="4567";
    var str5="567";
    var str6="67";
    var str7="7";
    kilo(str1);
    kilo(str2);
    kilo(str3);
    kilo(str4);
    kilo(str5);
    kilo(str6);
    kilo(str7);
    //第一种
    /*var str='21212121';
    var reg=/^(\d{1,2})?((?:\d{3})+)$/;
    str=str.replace(reg, function () {
        var s1=arguments[1];
        var s2=arguments[2];
        s2=s2.replace(/\d{3}/,function(){
            return ","+arguments[0];
        });
        return s1+s2;
    })*/

</script>
</body>
</html>